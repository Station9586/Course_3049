# 專案報告：基於變異數之適應性 LSB 隱寫術分析與實現

## 1. 專案簡介

本專案旨在實現並評估一種基於影像區塊複雜度之適應性最低有效位元（Adaptive LSB）隱寫技術。傳統的 LSB 隱寫術會在影像的所有像素中嵌入固定數量的位元，這種方式雖簡單，卻容易在影像的平滑區域（如天空、牆壁）造成可被察覺的失真。

本專案提出的適應性方法，透過分析影像各區塊的像素值變異數（Variance）來衡量其複雜度，並動態調整嵌入策略：在紋理複雜的區域嵌入資訊，而在視覺上敏感的平滑區域則不嵌入任何資訊。我們將此適應性方法與傳統固定嵌入 2-bit 的 LSB 方法進行比較，以驗證其在維持高嵌入容量的同時，是否能更有效地保持原始影像的視覺品質。

**核心比較點：**

* **適應性 LSB (k=0/2)**：在變異數低於閾值的平滑區塊不嵌入 (`k=0`)，在變異數高於閾值的複雜區塊嵌入 2 個 LSBs (`k=2`)。
* **傳統固定 LSB (k=2)**：對影像中所有可用像素，不分區域，一律嵌入 2 個 LSBs。

**評估指標：**

* 峰值信噪比 (Peak Signal-to-Noise Ratio, PSNR)
* 結構相似性指標 (Structural Similarity Index, SSIM)
* 實際嵌入容量 (Payload Capacity)
* 嵌入率 (Bits Per Pixel, bpp)

---

## 2. 系統架構與演算法說明

本系統包含兩種 LSB 嵌入與提取的演算法：適應性方法與固定方法。

### 2.1 核心技術

* **影像區塊複雜度分析**：使用像素值變異數 (`cv::meanStdDev`) 作為衡量 8x8 像素區塊複雜度的指標。高變異數通常意味著豐富的紋理或邊緣，適合隱藏資訊；低變異數則代表平滑區域，對修改較為敏感。
* **LSB 替換 (LSB Replacement)**：本專案所有嵌入操作均採用基礎的 LSB 替換法，直接用秘密位元覆蓋像素值的最低有效位。
* **非盲提取 (Non-Blind Extraction)**：在適應性方法中，提取秘密訊息時**必須提供原始的載體影像**。這是因為提取端需要重新計算原始影像各區塊的變異數，以同步嵌入端的決策（即判斷哪些區塊被用來藏資訊）。傳統固定 LSB 方法則屬於盲提取，僅需隱寫影像本身即可。

### 2.2 演算法流程

#### 2.2.1 適應性 LSB (Adaptive LSB)

**嵌入階段 (`embed_adaptive_lsb`):**

1.  **嵌入訊息長度**：讀取秘密訊息，計算其總位元長度。將此長度（一個32位元的整數）使用 `k=1` LSB 替換法，嵌入到載體影像最開頭的 32 個像素中。
2.  **適應性嵌入負載**：
    * 將影像（除去已用於嵌入長度的部分）分割成不重疊的 8x8 區塊。
    * 依序處理每個區塊：
        * **計算複雜度**：獲取**原始載體影像**對應區塊的像素，並計算其像素值變異數。
        * **決定嵌入策略**：
            * 若 `variance < 30.0`，判定為平滑區，`k=0`，**不嵌入資訊**並跳過此區塊。
            * 若 `variance >= 30.0`，判定為複雜區，`k=2`，在此區塊的每個像素中嵌入 2 個秘密位元。
        * 持續此過程，直到秘密訊息全部嵌入或所有區塊處理完畢。
3.  **輸出**：產生並儲存隱寫影像。

**提取階段 (`extract_adaptive_lsb`):**

1.  **提取訊息長度**：讀取隱寫影像最開頭 32 個像素的 LSB，還原出秘密訊息的總長度。
2.  **適應性提取負載**：
    * 與嵌入階段同步，將影像分割成 8x8 區塊。
    * 依序處理每個區塊：
        * 使用**原始載體影像**計算對應區塊的變異數，以複製嵌入時的判斷。
        * 若 `variance < 30.0`，則跳過此區塊。
        * 若 `variance >= 30.0`，則從此區塊的每個像素中提取 2 個 LSB。
    * 持續提取，直到達到先前讀取的訊息總長度。
3.  **輸出**：將提取的位元流轉換回原始字串。

#### 2.2.2 傳統固定 LSB (Fixed LSB)

**嵌入/提取階段 (`embed_fixed_lsb`, `extract_fixed_lsb`):**

其流程與適應性方法類似，但核心差異在於負載的嵌入與提取：**它不進行任何區塊劃分或變異數計算**。在嵌入完訊息長度後，直接從第 33 個像素開始，對影像中所有剩餘的像素**依序、無差別地**嵌入（或提取）2 個 LSBs，直到訊息結束或影像容量用盡。

---

## 3. 實驗設定與結果分析

### 3.1 實驗環境與參數

* **開發環境**：C++ 搭配 OpenCV 函式庫。
* **測試影像**：`img/image4.png` (128x128, 灰階)。
* **秘密訊息**：`secret.txt` (1729 bytes, 即 13832 bits)。
* **適應性參數**：`block_size = 8`, `variance_threshold = 30.0`。
* **固定 LSB 參數**：`k=2`。

### 3.2 實驗結果

| 方法                   | PSNR (dB)   | SSIM         | 實際嵌入位元數 | 嵌入率 (bpp) |
| :--------------------- | :---------- | :----------- | :------------- | :----------- |
| **適應性 LSB (k=0/2)** | **47.6125** | **0.989091** | 13832          | 0.844238     |
| **傳統固定 LSB (k=2)** | 47.4733     | 0.945332     | 13832          | 0.844238     |

*(註：bpp = 實際嵌入的秘密訊息負載位元數 / 影像總像素數)*

### 3.3 結果分析

從上述實驗結果可看出，在嵌入相同長度（13832 bits）的秘密訊息至同一張載體影像時：

1.  **PSNR 比較**：適應性 LSB 方法的 PSNR（**47.6125 dB**）略高於傳統固定 2-bit LSB 方法的 PSNR（47.4733 dB）。這驗證了適應性策略透過在平滑區域（低變異數區）避免嵌入資訊，從而更好地保護了影像的整體品質，減少了失真。
2.  **SSIM 比較**：適應性 LSB 方法的 SSIM（**0.989091**）明顯優於傳統方法（0.945332）。SSIM 更側重於影像的亮度、對比度和結構相似性，這一顯著差異強力證明了適應性方法在維持影像「看起來」的自然度與結構完整性方面，具有非常大的優勢。
3.  **策略有效性**：實驗數據確認，基於影像複雜度自適應地選擇嵌入強度（在此案例中為嵌入或不嵌入）的策略是高效的。它在達成相同嵌入容量的前提下，提供了比傳統固定方法更優越的影像品質，尤其是在 SSIM 這一更貼近人類視覺感知的指標上。

---

## 4. 結論與未來展望

本專案成功實現並評估了一種基於影像區塊變異數的適應性 LSB 隱寫技術。實驗結果清晰地表明，在嵌入相同資訊量的前提下，所提出的適應性方法能夠比傳統固定 LSB 方法獲得更高的 PSNR 和（更為顯著的）SSIM 值，從而產生視覺品質更佳、更不易被察覺的隱寫影像。

**未來可探討的方向：**

* **多層次 k 值與閾值優化**：探索更細緻的 k 值分配策略（例如 k=0, 1, 2, 3）以及對應的變異數閾值，以在容量和品質之間取得更佳平衡。
* **多種複雜度指標融合**：結合邊緣密度、熵等其他指標來更精準地評估區塊複雜度。
* **嵌入地圖**：研究如何安全高效地將記錄各區塊 k 值的「嵌入地圖」也藏入影像中，以實現盲提取。
* **彩色影像**：將目前的灰階處理擴展到彩色影像，並研究不同顏色通道的嵌入策略。

---

## 5. 程式碼結構與使用說明

* **主要函式**：
    * `embed_adaptive_lsb()` / `extract_adaptive_lsb()`: 適應性 LSB 嵌入/提取主邏輯。
    * `embed_fixed_lsb()` / `extract_fixed_lsb()`: 傳統固定 LSB 嵌入/提取主邏輯。
    * `calculate_block_variance()`: 計算區塊變異數。
    * `main()`: 主程式，負責讀取檔案、調用流程與展示比較結果。